from utils.indicators import get_crypto_indicators
from models.user import get_user_plan
from utils.auth import is_pro_plan
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ConversationHandler,
    filters
)

async def predict_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    plan = get_user_plan(user_id)
        

    if not is_pro_plan(plan):
        await update.message.reply_text(
            "üîí This feature is for *Pro users only*.\nUse /upgrade to unlock.",
            parse_mode="Markdown"
        )
        return

    args = context.args
    if not args:
        await update.message.reply_text("‚ùå Usage: /prediction BTC [timeframe]\nExample: /prediction ETH 4h")
        return

    symbol = args[0].upper()

    timeframe_map = {
    "1m": "1min",
    "5m": "5min",
    "15m": "15min",
    "30m": "30min",
    "1h": "1h",
    "2h": "2h",
    "4h": "4h",
    "8h": "8h",
    "1d": "1day",
    "1w": "1week"
    }
    
    user_input_tf = args[1] if len(args) > 1 else "1h"
    if user_input_tf not in timeframe_map:
        await update.message.reply_text("‚ùå Invalid timeframe. Use one of: 1m, 5m, 15m, 30m, 1h, 2h, 4h, 8h, 1d, 1w")
        return

    timeframe = timeframe_map[user_input_tf]

    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
    await update.message.reply_text("üß† Analyzing market conditions and predicting... Please wait...")

    # Fetch live price and indicators
    price = get_crypto_price(symbol)
    indicators = await get_crypto_indicators(symbol, timeframe)

    if price is None or indicators is None:
        await update.message.reply_text("‚ö†Ô∏è Could not fetch price or indicator data for this coin.")
        return

    prompt = f"""
    You're a crypto analyst. Based on the following data, give a brief, realistic short-term forecast for {symbol} in the next {timeframe}:

    ‚Ä¢ Price: ${price}
    ‚Ä¢ RSI: {safe(indicators.get('rsi'))}
    ‚Ä¢ MACD Histogram: {safe(indicators.get('macd'))}
    ‚Ä¢ EMA(20): {safe(indicators.get('ema20'))}
    ‚Ä¢ 24h High/Low: {safe(indicators.get('high_24h'))} / {safe(indicators.get('low_24h'))}
    ‚Ä¢ Volume: {safe(indicators.get('volume'))}

    Only include key insights and a directional prediction (up, down, or sideways). Be concise.
    """

    prediction = None

    try:
        fallback_response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {os.getenv('OPENROUTER_API_KEY')}",
                "Content-Type": "application/json"
            },
            json={
                "model": "mistralai/mixtral-8x7b-instruct",
                "messages": [
                    {"role": "user", "content": prompt}
                ]
            },
            timeout=20
        )

        if fallback_response.status_code == 200:
            prediction = fallback_response.json()["choices"][0]["message"]["content"].strip()
        else:
            print("OpenRouter response error:", fallback_response.status_code, fallback_response.text)
            await update.message.reply_text("‚ùå Fallback model failed. Please try again later.")
            return

    except Exception as e:
            print("Fallback error:", e)
            await update.message.reply_text("‚ùå Fallback error occurred. Please try again later.")
            return

    await update.message.reply_text(
        f"üìà *AI Prediction for {symbol} ({timeframe}):*\n\n{prediction}\n\n"
        "‚ö†Ô∏è _Disclaimer: This prediction is generated by AI based on market data and does not constitute financial advice._",
        parse_mode="Markdown"
    )